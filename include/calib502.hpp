/***********************************************
#
# Author: Sun Qinxuan
#
# Email: sunqinxuan@outlook.com
#
# Last modified:	2022-11-15 08:50
#
# Filename:		calib502.hpp
#
# Description:
#
************************************************/

#ifndef _CALIB502_HPP_
#define _CALIB502_HPP_

#include <float.h>
#include <list>
#include <map>
#include <math.h>
#include <queue>
#include <stdio.h>
#include <stdlib.h>

//#include <camera_info_manager/camera_info_manager.h>
#include <cv_bridge/cv_bridge.h>
//#include <geometry_msgs/PoseStamped.h>
//#include <image_transport/image_transport.h>
#include <ros/ros.h>
//#include <sensor_msgs/CameraInfo.h>
//#include <sensor_msgs/CompressedImage.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/image_encodings.h>
//#include <std_msgs/Float32MultiArray.h>
//#include <tf2_msgs/TFMessage.h>
//#include <perception_msgs/PerceptionLocalization.h>

#include <Eigen/Dense>
#include <Eigen/Geometry>
#include <boost/shared_ptr.hpp>
#include <sys/time.h>
#include <yaml-cpp/yaml.h>

#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl_conversions/pcl_conversions.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/point_cloud_conversion.h>

#include <opencv2/features2d/features2d.hpp>
#include <opencv2/imgproc/imgproc.hpp>
//#include <opencv2/nonfree/nonfree.hpp>
#include <opencv2/opencv.hpp>
//#include <opencv2/core/eigen.hpp>
//#include <opencv2/legacy/legacy.hpp>

#include "camera_model.hpp"
#include "registration.hpp"

namespace ZJL {
class Calib502 {
public:
  Calib502(const std::string &work_space_path);
  ~Calib502();

  bool
  runCalibTofNav(const cv::Mat &img_nav, const cv::Mat &img_tof_intensity,
                 const pcl::PointCloud<pcl::PointXYZI>::Ptr &point_cloud_tof,
                 const CameraModel &cam_nav, Eigen::Isometry3d &T_nav_tof);

  bool runCalibNavMultispec(const cv::Mat &img_left, const cv::Mat &img_right,
                            const cv::Mat &img_multispec,
                            const CameraModel &cam_left,
                            const CameraModel &cam_right,
                            const CameraModel &cam_multispec,
                            const Eigen::Isometry3d &T_left_right,
                            Eigen::Isometry3d &T_nav_multispec);

  // bool runCalibNavMultispec(const cv::Mat &img_nav_left,
  //                          const cv::Mat &img_nav_right,
  //                          const cv::Mat &img_multispec,
  //                          const CameraModel &cam_nav_left,
  //                          const CameraModel &cam_nav_right,
  //                          const CameraModel &cam_multispec,
  //                          const Eigen::Isometry3d &T_nav_left_right,
  //                          Eigen::Isometry3d &T_nav_multispec);

  static double deg2rad(double r) { return r * M_PI / 180.0; }

  // for debugging;
  timeval runtime_start, runtime_end;
  double runtime;
  std::ofstream fp;

  cv::Mat img_vis_1, img_vis_2;
  pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud_vis_1, cloud_vis_2;

private:
  // void callbackNavigationLeft(const sensor_msgs::Image::ConstPtr &msg);
  // void callbackNavigationRight(const sensor_msgs::Image::ConstPtr &msg);
  // void callbackTofRange(const sensor_msgs::Image::ConstPtr &msg);
  // void callbackTofIntensity(const sensor_msgs::Image::ConstPtr &msg);
  // void callbackTofCloud(const sensor_msgs::PointCloud2::ConstPtr &msg);

  void PCLPoint2Eigen(const pcl::PointXYZRGBA &pt, Eigen::Vector3d &vec) {
    vec[0] = pt.x;
    vec[1] = pt.y;
    vec[2] = pt.z;
  }

  bool generatePixelCloud(const cv::Mat &img_edge,
                          pcl::PointCloud<pcl::PointXY>::Ptr pixel_cloud);

  bool extractCannyEdge(const cv::Mat &img, const double canny_th1,
                        const double canny_th2, const double blur_size,
                        cv::Mat &img_edge);

  // visualizeEdges
  // output: img_edge
  // nav image edges in green;
  // tof image edges in red;
  // visualize edges extracted from nav camera and tof camera,
  // both in the image of nav camera;
  // there is a dilation for tof edges, because of the resolution difference;
  bool visualizeEdges(const cv::Mat &img_nav, const cv::Mat &img_tof,
                      const pcl::PointCloud<pcl::PointXYZI>::Ptr &cloud_tof,
                      const Eigen::Isometry3d &T_nav_tof,
                      const CameraModel &cam, cv::Mat &img_edges);

  // visualizePointCloud
  // visualize the point cloud generated by tof camera;
  // the points are colored by the measurements of nav left camera;
  // using the intrinsic "cam" and
  // the extrinsic "T_nav_tof";
  // cloud - output colored point cloud;
  bool
  visualizePointCloud(const cv::Mat &img_nav,
                      const pcl::PointCloud<pcl::PointXYZI>::Ptr &cloud_tof,
                      const Eigen::Isometry3d &T_nav_tof,
                      const CameraModel &cam,
                      pcl::PointCloud<pcl::PointXYZRGBA>::Ptr cloud);

  bool matchKeyPoints(const cv::Mat &img_1, const cv::Mat &img_2,
                      std::vector<cv::KeyPoint> &key_points_1,
                      std::vector<cv::KeyPoint> &key_points_2,
                      std::vector<cv::DMatch> &matches);

  bool matchKeyPoints2(const cv::Mat &img_1, const cv::Mat &img_2,
                       std::vector<cv::KeyPoint> &key_points_1,
                       std::vector<cv::KeyPoint> &key_points_2,
                       std::vector<cv::DMatch> &matches);

  Eigen::Vector3d Rotation2AxisAngle(const Eigen::Matrix3d &R) const;

  cv::Point2f mulMatPoint(const cv::Mat &mat, const cv::Point2f &pt) const;

private:
  ros::NodeHandle nh_;

  double canny_th1_tof_, canny_th2_tof_;
  double canny_th1_nav_, canny_th2_nav_;
  double orb_th_nav_multispec_, orb_th_nav_;

  std::shared_ptr<CannyRegistration> registration_ptr_;
};
} // namespace ZJL

#endif
